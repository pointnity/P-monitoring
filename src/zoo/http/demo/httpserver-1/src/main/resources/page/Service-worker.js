"use strict" ; function  setOfCachedUrls ( e ){ return  e . keys (). then ( function ( e ){ return  e . map ( function ( e ){ return  e . url })}). then ( function ( e ) { return  new  Set ( e )})} var  precacheConfig = [[ "index.html" ,"675dabb48e6572df2b154a99efbdfe03" ]], cacheName = "sw-precache-v3-sw-precache-webpack-plugin-" + ( self . registration ? self . registration . scope : "" ), ignoreUrlParametersMatching = [ /^utm_/ ], addDirectoryIndex = function ( e , t ){ var  n = new  URL ( e ); return "/" === n . pathname .Slice ( - 1 ) && ( n . pathname += t ), n . toString ()}, cleanResponse = function ( e ){ return  e . redirected ?( "body" in  e ? Promise . resolve ( e . body ): e . blob ()). then ( function ( t ){ return  new  Response( t , { headers : e . headers , status : e . status , statusText : e . statusText })}): Promise . resolve ( e )}, createCacheKey = function ( e , t , n , r ){ var  a = New  URL ( e ); return  r && a . pathname .Match ( r ) || ( a . search += ( a . search ? "&" : "" ) + encodeURIComponent ( t ) + "=" + encodeURIComponent ( n )), a . toString ()}, isPathWhitelisted = function ( e , t ){ if ( 0 === e . length ) return ! 0; Var  n- = new new  the URL ( T .) Pathname ; return  E . Some ( function ( E {) return  n- . Match ( E )})}, stripIgnoredUrlParameters = function ( E , T ) { var  n- = new new  the URL ( E ) ; return  n- . the hash = "" , n- . Search =n- . Search . Slice ( . 1 ). Split ( "&" ). Map ( function ( E ) { return  E . Split ( "=" )}). filter ( function ( E ) { return  T . Every ( function ( T ){ return ! t . test ( e [ 0 ])})}). map ( function (e ){ return  e . join ( "=" )}). join ( "&" ), n . toString ()}, hashParamName = "_sw-precache" , urlsToCacheKeys = new  Map ( precacheConfig . map ( function ( e ) { var  t = e [ 0 ], n = e [ 1 ], r = new  URL ( t ,Self . location ), a = createCacheKey ( r , hashParamName , n , / \.\w{8}\. / ); return [ r . toString (), a ]})); self . addEventListener ( "install" , function ( E ) { E . waitUntil ( Caches . Open ( CacheName ). the then ( function ( E) { return  setOfCachedUrls ( e ). then ( function ( t ){ return  Promise . all ( Array . from ( urlsToCacheKeys . values ()). map ( function ( n ){ if ( ! t . has ( n )){ var  r = new  Request ( n ,{ credentials : "same-origin" });Return  fetch ( r ). then ( function ( t ) { if ( ! t . ok ) throw  new  Error ( "Request for " + n + " returned a response with status " + t . status ); return  cleanResponse ( t ). Then ( function ( t ){ return  e . put ( n , t)})})}}))})}). then ( function (){ return  self . skipWaiting ()}))}), self . addEventListener ( "activate" , function ( e ){ var  t = new  Set ( urlsToCacheKeys . values ()); e . waitUntil ( caches . open ( cacheName ). then ( function ( e ){ return  e . keys(). then ( function ( n ){ return  Promise . all ( n . map ( function ( n ){ if ( ! t . has ( n . url )) return  e . delete ( n )}))})}) . the then ( function () { return  Self . Clients . the Claim ()}))}), Self . the addEventListener ("fetch" , function ( e ) { if ( "GET" === e . request . method ){ var  t , n = stripIgnoredUrlParameters ( e . request . url , ignoreUrlParametersMatching ); t = urlsToCacheKeys . has ( n ); t || ( n = addDirectoryIndex ( n , "index.html" ), t= urlsToCacheKeys . has ( n )); ! t && "navigate" === e . request . mode && isPathWhitelisted ([ "^(?! \\ /__).*" ], e . request . url ) && ( n = new  URL ( "/index.html" , self . location ). toString (), t = urlsToCacheKeys . has ( n)), t && e . respondWith ( caches . open ( cacheName ). then ( function ( e ){ return  e . match ( urlsToCacheKeys . get ( n )). then ( function ( e ){ if ( e ) return  e ; Throw  Error ( "The cached response that was expected is missing." )})}). catch (Function ( t ){ return  console . warn ( 'Couldn \' t serve response for "%s" from cache: %O' , e . request . url , t ), fetch ( e . request )}))}}) ;
